# Agent Instructions

This project uses @obra/superpowers

## Project Overview

**Bluefin Firehose** is a unified release dashboard that aggregates updates from three sources:
- **Bluefin OS releases** (from ublue-os/bluefin repository)
- **Flatpak applications** (42 curated apps from Bluefin's system Brewfiles)
- **Homebrew packages** (44 packages from Bluefin's CLI, AI, K8s, and IDE tool collections)
- **ublue-os tap packages** (41 packages from ublue-os/homebrew-tap and experimental-tap)

**Total: ~137 packages tracked**

The project uses a **hybrid architecture**: Go backend for data aggregation + Astro frontend for static site generation.

## Architecture

### Data Pipeline (Go)

**Entry Point:** `cmd/bluefin-releases/main.go`

The pipeline runs in three parallel phases:

1. **Flatpak Fetcher** (`internal/bluefin/flatpaks.go`)
   - Reads curated app lists from Bluefin Brewfiles (system-flatpaks.Brewfile, system-dx-flatpaks.Brewfile)
   - Fetches metadata from Flathub API via `internal/flathub/flathub.go`
   - Enriches with GitHub repo detection
   - ~42 apps total

2. **Homebrew Fetcher** (`internal/bluefin/homebrew.go`)
   - Reads package lists from Bluefin Brewfiles (cli.Brewfile, ai-tools.Brewfile, k8s-tools.Brewfile, ide.Brewfile)
   - Fetches metadata from Homebrew formulae API
   - Filters for Linux-compatible packages
   - Extracts GitHub repos for release tracking
   - ~44 packages total

3. **OS Releases Fetcher** (`internal/bluefin/releases.go`)
   - Fetches latest releases from ublue-os/bluefin GitHub repository
   - Parses release notes for version info and changelogs
   - ~10 releases total

4. **ublue-os Tap Packages** (`internal/bluefin/homebrew_taps.go`)
   - Discovers packages from ublue-os/homebrew-tap and experimental-tap GitHub repos
   - Uses GitHub Contents API to list .rb formula/cask files
   - Parses metadata with regex: desc, homepage, version, GitHub repo
   - Marks experimental-tap packages with flag
   - ~41 packages total

5. **GitHub Enrichment** (`internal/github/github.go`)
   - Fetches actual release notes from detected GitHub repos
   - Rate-limited and concurrent (respects GitHub API limits)
   - Falls back gracefully when token unavailable

**Output:** `src/data/apps.json` (unified data structure, ~137 packages total)

### Frontend (Astro)

**Entry Point:** `src/pages/index.astro`

- Imports JSON data from Go pipeline
- Renders responsive app cards (`src/components/AppCard.astro`)
- Implements filters (`src/components/FilterBar.astro`)
- Adds search and keyboard navigation
- Generates static HTML for GitHub Pages deployment

### Key Components

```
cmd/bluefin-releases/main.go    # Pipeline orchestration
internal/
  ├── models/models.go          # Unified data structures
  ├── bluefin/
  │   ├── flatpaks.go           # Bluefin Flatpak fetcher
  │   ├── homebrew.go           # Bluefin Homebrew fetcher
  │   ├── homebrew_taps.go      # ublue-os tap fetcher
  │   └── releases.go           # Bluefin OS releases fetcher
  ├── flathub/flathub.go        # Flathub API client
  └── github/github.go          # GitHub API client
src/
  ├── pages/index.astro         # Main page
  ├── components/               # UI components
  └── data/apps.json            # Generated by pipeline
```

## Development Workflow

### Local Development

```bash
# Install dependencies
npm install
go mod download

# Build pipeline + site
npm run build

# Preview the site
npm run preview

# Development mode (requires pre-generated data)
npm run dev
```

### Running the Pipeline

```bash
# Without GitHub integration (uses Flathub/Homebrew metadata only)
go run cmd/bluefin-releases/main.go

# With GitHub integration (fetches actual release notes)
GITHUB_TOKEN=your_token_here go run cmd/bluefin-releases/main.go
```

### Testing Changes

1. **Backend changes** (Go code):
   ```bash
   go run cmd/bluefin-releases/main.go  # Test pipeline
   cat src/data/apps.json | jq '.apps | length'  # Verify output
   ```

2. **Frontend changes** (Astro):
   ```bash
   npm run build  # Build site
   npm run preview  # Preview locally
   ```

3. **Full integration test**:
   ```bash
   npm run build  # Runs pipeline + builds site
   npm run preview  # Verify in browser
   ```

## Common Tasks

### Adding a New Data Source

1. Create fetcher in `internal/bluefin/` (e.g., `newsource.go`)
2. Implement fetcher function returning `[]models.App`
3. Add fetcher call to `cmd/bluefin-releases/main.go`
4. Update merge logic in main.go (Step 4)
5. Test with `go run cmd/bluefin-releases/main.go`

### Modifying the UI

1. Edit components in `src/components/`
2. Update main page in `src/pages/index.astro`
3. Test with `npm run build && npm run preview`
4. Check responsive design (mobile/tablet/desktop)

### Debugging the Pipeline

1. **Check pipeline logs:**
   ```bash
   go run cmd/bluefin-releases/main.go 2>&1 | tee pipeline.log
   ```

2. **Inspect output JSON:**
   ```bash
   cat src/data/apps.json | jq '.metadata'  # Check metadata
   cat src/data/apps.json | jq '.apps[0]'   # Check first app
   cat src/data/apps.json | jq '.apps | map(.packageType) | group_by(.) | map({type: .[0], count: length})'  # Count by type
   ```

3. **Test specific fetchers:**
   ```bash
   # Add debug prints to fetcher functions
   # Run pipeline and check logs
   ```

4. **GitHub API issues:**
   ```bash
   # Check rate limits
   curl -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/rate_limit
   
   # Test specific repo
   curl -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/repos/ublue-os/bluefin/releases
   ```

### Performance Tuning

Typical build times:
- **Flatpak fetch**: ~600-800ms (42 apps, parallel)
- **Homebrew fetch**: ~200-300ms (44 packages, parallel)
- **Tap fetch**: ~3-5s (41 packages, GitHub API + file fetching)
- **Bluefin OS fetch**: ~300ms (10 releases)
- **GitHub enrichment**: ~10-20s with token (rate-limited)
- **Astro build**: ~600ms
- **Total**: ~5-8s (no GitHub) or ~25-35s (with GitHub)

To optimize:
1. Reduce GitHub API calls (cache, batch, or filter repos)
2. Parallelize more operations (currently Flatpak/Homebrew/OS are sequential)
3. Use Go's `errgroup` for better concurrency control

## Deployment

The site deploys automatically via GitHub Actions (`.github/workflows/deploy.yml`):
- **Trigger**: Every 6 hours + on push to main + manual dispatch
- **Process**: Run Go pipeline → Build Astro site → Deploy to GitHub Pages
- **Environment**: `GITHUB_TOKEN` is auto-provided by GitHub Actions

## Feature Completion Validation Protocol

**CRITICAL**: Before closing ANY issue or marking work complete, you MUST follow this protocol. Multiple issues have been falsely marked complete without actual implementation.

### The Problem: False Completions

Past failures have occurred due to:
1. **Claiming work was done without committing code** - Issues closed with detailed descriptions, but `git log` shows no matching commits
2. **Partial implementation** - Feature added to one component (e.g., AppCard) but missed in others (e.g., ReleaseCard)
3. **Incomplete global changes** - CSS color updates that fixed some files but missed others, including fallback values
4. **No verification** - Work marked complete without building, grep checking, or visual inspection
5. **Megacommit masking** - Claiming "completed 10 issues" in one commit that only changed JSON files, not actual code

### Mandatory Validation Checklist

**FOR EVERY FEATURE/FIX** you implement, complete this checklist **BEFORE** closing the issue:

#### 1. Implementation Verification
```bash
# Verify code was actually changed
git status                    # Shows modified files
git diff                      # Shows actual changes made

# Verify the feature exists where it should
grep -r "feature-keyword" src/  # Search for your feature (e.g., "flathub-badge")
```

**✅ PASS**: Modified files match the issue requirements  
**❌ FAIL**: No files changed, or wrong files changed → **DO NOT close issue**

#### 2. Global Search for Incomplete Changes

If the change should apply globally (CSS colors, repeated components):
```bash
# Find ALL instances that need changing
grep -rn "#0969da\|#4a90e2" src/ --include="*.astro"  # Example: find wrong colors
grep -rn "old-pattern" src/                           # Find old patterns
grep -rn "rgba(9, 105, 218" src/                      # Find rgba form of colors
```

**✅ PASS**: Zero results for old/wrong patterns (or only acceptable exceptions like gradients)  
**❌ FAIL**: Old patterns remain → **REOPEN, fix ALL instances**

#### 3. Build Verification
```bash
npm run build   # MUST succeed without errors
```

**✅ PASS**: Build completes successfully  
**❌ FAIL**: Build errors → **Fix errors before closing issue**

#### 4. Visual Verification
```bash
npm run preview  # Start preview server
# Open browser and CHECK:
# - Feature appears where expected
# - Styling is correct (colors, spacing, alignment)
# - Feature works on both light/dark themes
# - No console errors
```

**✅ PASS**: Feature visible and working correctly  
**❌ FAIL**: Feature missing or broken → **Fix before closing issue**

#### 5. Atomic Commit
```bash
# Create ONE commit per feature/fix
git add <specific-files>     # Only files related to THIS feature
git commit -m "Detailed message explaining what/why"

# Verify commit contains expected changes
git show HEAD --stat         # Check files changed
git show HEAD                # Review actual changes
```

**Commit message format:**
```
<action> <what> - <brief why>

<detailed description of changes>
- Bullet point changes
- With file names and line numbers where helpful

Verification:
- Build succeeds
- grep confirms <old-pattern> removed
- Feature appears in <location>
```

**✅ PASS**: Commit contains only this feature's changes, message is detailed  
**❌ FAIL**: Megacommit with multiple features, vague message → **Split into atomic commits**

#### 6. Issue Closure

Document completion with clear evidence in commit message and issue tracker:

**✅ PASS**: Issue closed with evidence of completion in commit message  
**❌ FAIL**: Closed with vague message like "done" → **Reopen and add verification**

### Examples of Proper vs Improper Completion

#### ❌ IMPROPER (DO NOT DO THIS):
```bash
# Make some changes (maybe)
git commit -m "Added Flathub badge to components"
# No build check, no grep, no visual verification
# Issue closed but feature is actually missing from ReleaseCard!
```

#### ✅ PROPER (DO THIS):
```bash
# 1. Implement feature in ALL required locations
# 2. Check with grep
grep -n "flathub-badge" src/components/ReleaseCard.astro
# Output: 154:  class="flathub-badge-link"  ✅ Confirmed present

grep -n "flathub-badge" src/components/AppCard.astro
# Output: 151:  class="flathub-badge-link"  ✅ Confirmed present

# 3. Build
npm run build  # ✅ Success

# 4. Visual check
npm run preview  # ✅ Badge appears on both card types

# 5. Atomic commit
git add src/components/ReleaseCard.astro
git commit -m "Add Flathub install badge to ReleaseCard component

- Add badge HTML and CSS to ReleaseCard
- Matches AppCard implementation
- Only shows for packageType === 'flatpak'

Verification:
- Build succeeds
- grep confirms badge in both AppCard and ReleaseCard
- Visual check: badge appears in Recent Releases view"
```

### Red Flags That Indicate False Completion

Watch for these warning signs:
- ⚠️ Issue closed but `git log` shows no recent commits for that feature
- ⚠️ Commit message says "completed 10 issues" but changes only 1-2 files
- ⚠️ Close reason is vague: "done", "fixed", "added feature"
- ⚠️ No verification commands were run (no build, no grep, no preview)
- ⚠️ `git diff` before commit showed changes, but after commit those files aren't in git history
- ⚠️ CSS changes that updated variables but ignored fallback values like `var(--color, #fallback)`

### When to Reopen Issues

Immediately reopen an issue if:
1. **Feature is missing** - grep/visual check shows feature isn't actually there
2. **Partial implementation** - Feature in some locations but not all required locations
3. **Build fails** - npm run build errors after "completed" work
4. **No commit** - Issue closed but no git commit exists for the feature
5. **Wrong commit** - Commit message claims feature but `git show` doesn't show the actual code

**When reopening:**
Document in issue tracker why it was reopened:
- "Reopened: Feature claimed complete but grep shows missing from ReleaseCard.astro. AppCard has it (line 151) but ReleaseCard does not. Need to add badge HTML+CSS to ReleaseCard."

### Root Cause: Why Validations Were Skipped

Understanding why false completions happen:
1. **Overpromising** - Trying to complete too many issues at once leads to corners cut
2. **Trust without verification** - Assuming if you wrote the code, it must be correct
3. **Preview skipping** - Thinking "build passed" means feature works (it doesn't - build success ≠ feature present)
4. **Grep laziness** - Not searching for ALL instances of a pattern (e.g., forgetting rgba form of hex colors)
5. **Pressure to close** - Feeling pressure to show progress leads to premature closure

**Solution**: Slow down. One feature at a time. Verify thoroughly. Never close without evidence.

## Landing the Plane (Session Completion)

**When ending a work session**, you MUST complete ALL steps below. Work is NOT complete until `git push` succeeds.

**MANDATORY WORKFLOW:**

1. **File issues for remaining work** - Create issues for anything that needs follow-up
2. **Run quality gates** (if code changed) - Tests, linters, builds
   ```bash
   # For Go changes
   go run cmd/bluefin-releases/main.go  # Verify pipeline works
   
   # For frontend changes
   npm run build  # Verify site builds
   ```
3. **Update issue status** - Close finished work, update in-progress items
4. **PUSH TO REMOTE** - This is MANDATORY:
   ```bash
   git pull --rebase
   git push
   git status  # MUST show "up to date with origin"
   ```
5. **Clean up** - Clear stashes, prune remote branches
6. **Verify** - All changes committed AND pushed
7. **Hand off** - Provide context for next session

**CRITICAL RULES:**
- Work is NOT complete until `git push` succeeds
- NEVER stop before pushing - that leaves work stranded locally
- NEVER say "ready to push when you are" - YOU must push
- If push fails, resolve and retry until it succeeds

## Debugging Tips

### Common Issues

1. **Pipeline fails to fetch Flatpak apps**
   - Check if Flathub API is accessible: `curl https://flathub.org/api/v2/appstream`
   - Verify app IDs in Brewfiles are valid
   - Check logs for rate limiting or network errors

2. **Homebrew packages missing**
   - Verify Homebrew formulae API: `curl https://formulae.brew.sh/api/formula/PACKAGE_NAME.json`
   - Check if package is Linux-compatible (some are macOS-only)
   - Ensure Brewfiles are properly formatted

3. **GitHub enrichment fails**
   - Check `GITHUB_TOKEN` is set and valid
   - Verify rate limits: `curl -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/rate_limit`
   - Pipeline will work without GitHub token (uses Flathub/Homebrew metadata only)

4. **Astro build fails**
   - Ensure `src/data/apps.json` exists and is valid JSON
   - Check Node.js version (requires 20+)
   - Run `npm install` to ensure dependencies are installed

5. **Site deployed but shows old data**
   - Check GitHub Actions logs for pipeline failures
   - Verify `apps.json` was updated in the build artifact
   - Clear browser cache and hard reload

